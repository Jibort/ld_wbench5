# S√≠ntesi Completa del Projecte Sabina - Actualitzaci√≥ 19 de Maig 2025
Data: 19 de maig de 2025 - Conversa amb Claude
Projecte: Sabina (ld_wbench5) - Flutter Framework
Versi√≥: 1.2.5

üìã Context General del Projecte
Objectiu del Projecte
Sabina √©s un framework Flutter personalitzat que implementa una arquitectura MVC de tres capes, amb un sistema avan√ßat de traduccions i gesti√≥ d'estat sense dependencies externes.

Arquitectura Implementada
- Framework: Flutter amb patr√≥ MVC customitzat (Three-Layer)
- Gesti√≥ d'estat: Sense dependencies externes (NO GetX, NO Provider)
- Sistema de traduccions: Claus prefixades amb "##", gesti√≥ via StringTx.tx()
- Mapes: √ös de LdMap<T> en lloc de Map<String, T> arreu del projecte

Arquitectura Three-Layer
1. Widget Layer: Nom√©s configuraci√≥, delega al controller
   - Fitxers: *_widget.dart
   - Responsabilitat: Configuraci√≥ UI, delegaci√≥ al controller

2. Controller Layer: Gestiona l√≤gica, events i crea models
   - Fitxers: *_ctrl.dart
   - Responsabilitat: L√≤gica de negoci, gesti√≥ d'eventos, creaci√≥ de models

3. Model Layer: Estat persistent amb pattern Observer
   - Fitxers: *_model.dart
   - Responsabilitat: Estat de dades, notificacions de canvis

üèó M√≤duls Principals

Core Components
- LdWidgetAbs: Classe base per tots els widgets
- LdWidgetCtrlAbs: Classe base per controllers
- LdWidgetModelAbs: Classe base per models
- LdModelObserverIntf: Interf√≠cie per observar canvis

Widgets Implementats
- LdButton: Bot√≥ amb traduccions i eventos
- LdLabel: Etiqueta amb suport RichText
- LdTextField: Camp de text (en desenvolupament)
- LdThemeSelector: Selector de temes complet
- LdThemeViewer: Visualitzador de propietats de tema
- LdAppBar: AppBar personalitzada amb traduccions
- LdScaffold: Scaffold unificat amb l'arquitectura
- LdFoldableContainer: Contenidor plegable amb gesti√≥ d'estat i animaci√≥

Serveis
- TimeService: Gesti√≥ del temps amb observers
- L (LanguageService): Gesti√≥ d'idiomes i traduccions
- ThemeService: Servei unificat de gesti√≥ de temes (ara √∫nic, LdTheme eliminat)
- GlobalVariablesService: Variables autom√†tiques per interpolaci√≥
- MapsService: Gesti√≥ centralitzada de mapes de configuraci√≥

üéØ Problemes Recents Resolts

Problema de Rendiment amb LdLabels Reactius (Resolt) ‚≠êÔ∏è
- S√≠mptoma: La p√†gina de test es reconstru√Øa completament cada 500ms, causant problemes de rendiment
- Causa: El `setState()` al function observer `_obsTimer` reconstru√Øa tota la p√†gina en lloc de nom√©s el LdLabel
- Soluci√≥: Implementaci√≥ d'un m√®tode `setTranslationArgsIsolated()` per actualitzar nom√©s l'LdLabel espec√≠fic
- Impacte: Millora significativa en rendiment, sobretot en dispositius de gamma mitjana/baixa

Problema de Duplicitat de Serveis (Resolt)
- S√≠mptoma: Dos serveis redundants (LdTheme i ThemeService) 
- Causa: Implementacions paral¬∑leles amb funcionalitat similar
- Soluci√≥: Unificaci√≥ en ThemeService √∫nic, eliminaci√≥ de LdTheme

Error en Gesti√≥ de Temes (Resolt)
- S√≠mptoma: Variables privades declarades per√≤ no usades en ThemeService
- Causa: Problemes en la implementaci√≥ del patr√≥ singleton i notificacions
- Soluci√≥: Implementaci√≥ correcta amb ValueNotifier i √∫s de singletons

Problema amb APIs Obsoletes (Resolt)
- S√≠mptoma: √ös de par√†metres deprecats de ColorScheme (background, onBackground)
- Causa: Codi escrit sense actualitzar a les darreres recomanacions de Flutter
- Soluci√≥: Refactoritzaci√≥ amb √∫s de surface i onSurface en lloc dels deprecats

Problema LdLabels Reactius (Resolt) ‚≠êÔ∏è
- Context: LdLabels amb arguments d'interpolaci√≥ no s'actualitzaven quan canviaven les dades del model
- S√≠mptomes: Etiquetes d'hora, comptadors i idioma no s'actualitzaven correctament
- Soluci√≥ implementada: Patr√≥ Function Observer amb setTranslationArgs()
- Regla d'Or: Qualsevol LdLabel que mostri dades que canvien SEMPRE necessita un function observer dedicat

Actualitzacions 19 maig 2025 - Resoluci√≥ de Problemes amb LdFoldableContainer

1. **P√®rdua de Tags i Excepcions amb LdFoldableContainer**:
   - **Problema**: Al obrir i tancar un LdFoldableContainer, els widgets fills es recreaven completament perdent els seus tags i models, causant excepcions de null convertint-se en String
   - **Causa**: El contenidor no preservava els widgets durant l'animaci√≥ d'expansi√≥/contracci√≥
   - **Soluci√≥ implementada**:
     - Preservaci√≥ del mateix widget en els estats expandit i contret
     - Implementaci√≥ de mecanisme de recuperaci√≥ autom√†tica de models perduts
     - Millor gesti√≥ de nul¬∑litat als models

2. **Problema d'Amplada del Contingut en LdFoldableContainer**:
   - **Problema**: El contingut dels contenidors no ocupava tota l'amplada disponible
   - **Causa**: Falta de configuraci√≥ d'amplada adequada als widgets interiors
   - **Soluci√≥**: 
     - √ös de `width: double.infinity` en components clau
     - Implementaci√≥ de `crossAxisAlignment: CrossAxisAlignment.stretch`
     - Millor estructura del widget amb `widthFactor: 1.0` en Align

3. **Problemes d'Animaci√≥ amb Overflow i Constraints**:
   - **Problema**: Error en expandir/contraure contenidors: "Cannot interpolate between finite constraints and unbounded constraints"
   - **Causa**: Intentar animar entre al√ßada `null` (unbounded) i un valor finit (0.0)
   - **Soluci√≥**:
     - Substituci√≥ de `null` per un valor finit calculat
     - Implementaci√≥ de scroll individual per a cada contingut expandit
     - Reducci√≥ de l'al√ßada m√†xima dels contenidors expandits

4. **Problema de Preservaci√≥ del Focus en TextFields**:
   - **Problema**: En obrir o tancar un contenidor, es perdia el focus en els camps de text
   - **Causa**: Reconstrucci√≥ completa dels widgets fills durant l'animaci√≥
   - **Soluci√≥**:
     - Desar l'√∫ltim node de focus abans de contraure
     - Restaurar el focus despr√©s de l'animaci√≥ d'expansi√≥
     - Preservaci√≥ de widgets durant l'animaci√≥

5. **Overflow Vertical amb RenderFlex en P√†gines amb M√∫ltiples LdFoldableContainer** (Nou) ‚≠êÔ∏è:
   - **Problema**: Error "A RenderFlex overflowed by 3305 pixels on the bottom"
   - **Causa**: Al√ßada excessiva en contenidors expandits i manca d'estructura d'scroll adequada
   - **Soluci√≥**:
     - Canvi de SingleChildScrollView a ListView per millor rendiment
     - Limitaci√≥ d'al√ßades m√†ximes dels contenidors expandits a 180px
     - Implementaci√≥ d'scroll individual a cada contingut expandit
     - Optimitzaci√≥ de l'estructura de widgets per reduir anidaci√≥

6. **P√®rdua d'Estat en Canvis d'Idioma o Tema** (Nou) ‚≠êÔ∏è:
   - **Problema**: Els valors dels camps d'entrada i comptadors es perdien en canviar l'idioma o tema
   - **Causa**: Reconstrucci√≥ completa de l'aplicaci√≥ sense mecanisme de persist√®ncia d'estat
   - **Soluci√≥**:
     - Implementaci√≥ d'un mapa est√†tic `_persistentState` per desar l'estat entre reconstruccions
     - Desar l'estat abans de qualsevol canvi d'idioma o tema
     - Restauraci√≥ de l'estat al reconstruir la p√†gina
     - Utilitzaci√≥ de callbacks en lloc de refer√®ncies directes per actualitzar valors persistents

7. **Error amb LdTaggableMixin en Inicialitzar Widgets** (Nou):
   - **Problema**: AssertionError 'state != null' quan s'intentava accedir a l'estat del widget abans de muntar-se
   - **Causa**: Intent d'accedir directament a propietats de widgets acabats de crear
   - **Soluci√≥**:
     - Evitar refer√®ncies directes a widgets i usar callbacks per obtenir/establir valors
     - Implementaci√≥ d'un patr√≥ m√©s robust per la persist√®ncia i recuperaci√≥ d'estat
     - Millor gesti√≥ del cicle de vida dels widgets

üèó Sistema de Traduccions i Interpolaci√≥

Classes Clau
- StringTx: Gesti√≥ de traduccions amb interpolaci√≥
- Extensions String: Simplificaci√≥ d'√∫s (.tx, .txWith, .txArgs)
- GlobalVariablesService: Variables autom√†tiques per interpolaci√≥

Suport per Par√†metres
- Posicionals: {0}, {1}, etc.
- Nomenats: {name}, {count}, etc.
- Variables autom√†tiques: {current_date}, {user_name}, etc.

Millores Recents al Sistema de Traduccions
- **Detecci√≥ de m√∫ltiples claus**: Ara es detecten i tradueixen totes les claus "##" dins d'un text
- **Interpolaci√≥ separada**: Separaci√≥ clara entre traducci√≥ i interpolaci√≥ amb m√®tode `applyInterpolation`
- **Gesti√≥ de textos pretradu√Øts**: Si el text no comen√ßa amb "##", nom√©s s'aplica interpolaci√≥

üîß Components Clau Implementats

TimeService amb Model Observable
- Sincronitzaci√≥ amb servidor cada 30 segons
- Actualitzaci√≥ local cada 500ms
- Pattern Observer per notificar canvis

ThemeService - Sistema Unificat de Temes
- 8 temes predefinits (Sabina, Natura, Foc, Nit, Custom1, Custom2, DexeusClear, DexeusDark)
- Suport per modes (clar, fosc, sistema)
- Implementaci√≥ robusta amb ValueNotifier i fallbacks
- Selector i visualitzador de temes integrats

Sistema d'Events
- EventBus centralitzat
- Suport per events targetsats i globals
- Gesti√≥ de languageChanged, themeChanged, rebuildUI

LdTextField amb Model Robust
- Gesti√≥ correcta de valors nuls
- Creaci√≥ de models amb fallbacks adequats
- Integraci√≥ amb el sistema de traduccions

LdFoldableContainer - Widget Plegable Optimitzat
- Preservaci√≥ de widgets durant animaci√≥ expandir/contraure
- Gesti√≥ robusta del model amb autorecuperaci√≥
- Suport per scroll individual en continguts expandits
- Restauraci√≥ autom√†tica de focus

üìã Patrons Optimitzats per Components Reactius

### Patr√≥ Standard per LdLabels Reactius ‚≠êÔ∏è

```dart
// 1. Crear LdLabel
labTime = LdLabel(
  key: ValueKey(tagLabTime), 
  pTag: tagLabTime,
  pLabel: L.sCurrentTime,
  pPosArgs: [TimeService.s.model.formattedTime],
  style: Theme.of(context).textTheme.bodyMedium,
);

// 2. Crear Function Observer dedicat
_obsTimer = (LdModelAbs pModel, void Function() pfnUpdate) {
  if (pModel == TimeService.s.model && mounted) {
    final time = TimeService.s.model.formattedTime;
    
    if (labTime != null) {
      pfnUpdate();
      
      // Per components que s'actualitzen freq√ºentment, usar:
      labTime!.setTranslationArgsIsolated(positionalArgs: [time]);
      
      // Per components menys freq√ºentment actualitzats
      // setState(() {
      //   labTime!.setTranslationArgs(positionalArgs: [time]);
      // });
    }
  }
};

// 3. Connectar Function Observer (MAI connectar directament)
TimeService.s.model.attachObserverFunction(_obsTimer);

// 4. Desconnectar al dispose()
@override
void dispose() {
  TimeService.s.model.detachObserverFunction(_obsTimer);
  super.dispose();
}
```

### Patr√≥ per LdTextField Robust

```dart
/// Crea el model del TextField amb gesti√≥ d'errors i fallbacks
void _createModel() {
  try {
    // Crear el model amb la configuraci√≥ del widget
    model = LdTextFieldModel.fromMap(widget.config);
  } catch (e) {
    Debug.error("$tag: Error creant model: $e");
    // Crear un model de recanvi amb un text per defecte
    try {
      // Nom√©s cal garantir que mfText t√© un valor
      MapDyns fallbackConfig = MapDyns();
      fallbackConfig[mfText] = "";
      
      model = LdTextFieldModel.fromMap(fallbackConfig);
    } catch (e2) {
      Debug.error("$tag: Error creant model de recanvi: $e2");
    }
  }
}

// A LdTextFieldModel.fromMap
LdTextFieldModel.fromMap(MapDyns pMap) : super.fromMap(pMap) {
  // Assegurar que text t√© un valor v√†lid (no null)
  final textValue = pMap[mfText] as String? ?? 
                    pMap[mfInitialText] as String? ?? 
                    "";
  text = textValue;  // Aix√≤ usar√† el setter text=
}
```

### Patr√≥ per Preservaci√≥ de Widgets en LdFoldableContainer ‚≠êÔ∏è

```dart
// PRE-CONSTRUIR el contingut (sempre el mateix widget)
final contentChild = Padding(
  padding: contentPadding,
  child: content,
);

// Construir contenidor amb animaci√≥
return Column(
  mainAxisSize: MainAxisSize.min,
  crossAxisAlignment: CrossAxisAlignment.stretch, // Amplada completa
  children: [
    // Cap√ßalera (sempre visible)
    header,
    
    // Contingut (amb animaci√≥)
    AnimatedContainer(
      duration: _animationDuration,
      curve: Curves.easeInOut,
      // Mai usar 'null' com al√ßada en un AnimatedContainer
      height: containerModel.isExpanded ? maxExpandedHeight : 0.0,
      width: double.infinity, // For√ßar amplada completa
      // ... resta de configuraci√≥ ...
      child: ClipRect(
        child: Align(
          alignment: Alignment.topCenter,
          widthFactor: 1.0, // Factor d'amplada 100%
          child: SingleChildScrollView( // Scroll individual
            child: AnimatedOpacity(
              opacity: containerModel.isExpanded ? 1.0 : 0.0,
              duration: _animationDuration,
              // IMPORTANT: Usar el mateix widget fill en ambd√≥s casos!
              child: IgnorePointer(
                // Nom√©s ignorar interaccions quan est√† contret
                ignoring: !containerModel.isExpanded,
                // Sempre mantenir el MATEIX widget
                child: SizedBox(
                  width: double.infinity, // Amplada completa
                  child: contentChild, // Widget pre-constru√Øt
                ),
              ),
            ),
          ),
        ),
      ),
    ),
  ],
);
```

### Patr√≥ per Persist√®ncia d'Estat entre Reconstruccions (Nou) ‚≠êÔ∏è

```dart
// PERSIST√àNCIA D'ESTAT =================================
/// Map per desar l'estat entre reconstruccions
static final MapDyns _persistentState = MapDyns();

@override
void initialize() {
  // Recuperar valors persistents o crear nous
  if (_persistentState.isEmpty) {
    // Primera inicialitzaci√≥ - guardar valors per defecte
    model = TestPageModel(
      pPage: cPage,
      pTitleKey: titleKey,
      pSubTitleKey: subTitleKey,
    );
    
    // Inicialitzar valors per defecte
    _persistentState['saved_text_field_value'] = "";
    _persistentState[mfCounter] = 0;
    
    Debug.info("$tag: Creat nou model de p√†gina");
  } else {
    // Restauraci√≥ d'un estat previ
    try {
      // Recuperar l'estat del model
      model = TestPageModel.fromMap(cPage, _persistentState);
      Debug.info("$tag: Restaurat model de p√†gina des d'estat persistent");
    } catch (e) {
      // Si hi ha error en restaurar, crear un nou model
      Debug.error("$tag: Error restaurant model: $e");
      model = TestPageModel(
        pPage: cPage,
        pTitleKey: titleKey,
        pSubTitleKey: subTitleKey,
      );
    }
  }
}

// Guardar estat abans de qualsevol canvi significatiu
LdButton(
  text: L.sChangeLanguage,
  onPressed: () {
    // Guardar estat abans de canviar l'idioma
    _saveState();
    L.toggleLanguage();
  },
),

// Crear LdTextField amb callback per actualitzar estat
LdTextField(
  pTag: "TestTextField",
  initialText: _persistentState['saved_text_field_value'] as String? ?? "",
  label: L.sTextField,
  helpText: L.sTextFieldHelp,
  onTextChanged: (newText) {
    // Actualitzar directament l'estat persistent
    _persistentState['saved_text_field_value'] = newText;
  },
),

/// Guarda l'estat actual per a futures reconstruccions
void _saveState() {
  final currentModel = model as TestPageModel?;
  if (currentModel != null) {
    // Convertir el model a un mapa i guardar-lo
    final modelMap = currentModel.toMap();
    
    // Nom√©s actualitzar els camps que existeixen
    for (final entry in modelMap.entries) {
      _persistentState[entry.key] = entry.value;
    }
    
    Debug.info("$tag: Estat del model desat per a persist√®ncia");
  }
}

@override
void dispose() {
  // Desar l'estat final abans de disposar
  _saveState();
  super.dispose();
}
```

### Patr√≥ per Gesti√≥ Segura de LdFoldableContainer Reconstru√Øts

```dart
@override
Widget buildContent(BuildContext context) {
  final config = widget.config;
  final containerModel = model as LdFoldableContainerModel?;
  
  // Si no hi ha model, mostrar container buit o recuperar-lo
  if (containerModel == null) {
    _createBackupModel();  // Intent de recuperaci√≥
    return Container(
      height: 50,
      width: double.infinity,
      child: Center(child: Text("Recuperant contingut...")),
    );
  }
  
  // Resta del codi amb el model verificat
  // ...
  
  // Utilitzar Visibility per mantenir l'estat per√≤ gestionar millor l'espai
  return Column(
    // ...
    children: [
      // ...
      AnimatedContainer(
        // ...
        child: Visibility(
          visible: containerModel.isExpanded,
          maintainState: true,
          maintainAnimation: true,
          maintainSize: false,
          child: contentWidget,
        ),
      ),
    ],
  );
}
```

üöÄ Estat Actual i Pr√≤xims Passos

‚úÖ Completat
- ‚úì Arquitectura three-layer estable i documentada
- ‚úì Sistema de traduccions amb interpolaci√≥ avan√ßada i m√∫ltiples claus
- ‚úì Pattern Observer per LdLabels reactius
- ‚úì Gesti√≥ de temes completa (ThemeService)
- ‚úì Documentaci√≥ independent d'estil i errors
- ‚úì Widgets principals implementats
- ‚úì Refactoritzaci√≥ i unificaci√≥ de serveis de tema
- ‚úì Eliminaci√≥ de par√†metres deprecats de ColorScheme
- ‚úì Optimitzaci√≥ de rendiment per a LdLabels din√†mics
- ‚úì Correcci√≥ d'errors en LdTextField
- ‚úì Correcci√≥ de problemes en LdFoldableContainer
  - ‚úì Preservaci√≥ de widgets durant animaci√≥
  - ‚úì Gesti√≥ de focus
  - ‚úì Al√ßades din√†miques per evitar overflow
- ‚úì Implementaci√≥ de persist√®ncia d'estat entre reconstruccions
  - ‚úì Manteniment de valors en canvis d'idioma i tema
  - ‚úì Recuperaci√≥ robusta de models
  - ‚úì Evitar reconstruccions innecess√†ries

üìã Activitats Actuals
- Optimitzaci√≥ d'estructura de p√†gines amb m√∫ltiples LdFoldableContainer
- Implementaci√≥ de patrons de persist√®ncia d'estat global
- Millora de la gesti√≥ d'errors i recuperaci√≥ autom√†tica
- Reducci√≥ de la complexitat d'anidaci√≥ de widgets
- Estabilitzaci√≥ de components amb estat en reconstruccions totals

üìã Backlog Prioritat Mitjana
- Completar implementaci√≥ RichText en LdLabel
- Resoldre problemes visuals de selecci√≥ de tema
- Implementar tests unitaris per components principals
- Optimitzar rendiment global de l'arquitectura
- Finalitzar implementaci√≥ robusta de LdTextField

üîß Millores Futures
- Implementar sistema de logs m√©s robust
- Afegir support per themes din√†mics
- Crear documentaci√≥ autom√†tica dels widgets
- Implementar testing framework espec√≠fic per l'arquitectura
- Millorar les optimitzacions de rendiment per a components complexos
- Millorar la interacci√≥ entre LdFoldableContainer i altres components complexos

üìù Notes per Sessions Futures

Recordatoris Importants
‚ö†Ô∏è **OBLIGATORI**: Sempre rebre tres fitxers al comen√ßar nova conversa:
1. S√≠ntesi de converses (aquest document)
2. Normes d'estil (document independent)
3. Errors comuns (document independent)

Caracter√≠stiques Clau a Recordar
- Patr√≥ Function Observer per LdLabels reactius (SEMPRE)
- √ös de `setTranslationArgsIsolated` per actualitzacions freq√ºents
- Doble revisi√≥ obligat√≤ria abans de lliurar codi
- Constants cf/mf/ef segons funcionalitat
- Imports sempre amb package complet
- Comentaris //JIQ>CLA s'eliminen autom√†ticament
- Dates de creaci√≥ sempre es preserven en cap√ßaleres de fitxers
- Gesti√≥ de traduccions amb m√∫ltiples claus dins d'un text
- Fallbacks robustos en creaci√≥ de models per evitar errors de tipus
- Preservaci√≥ de widgets en animacions (especialment en contenidors plegables)
- Al√ßades finites en AnimatedContainer (mai 'null')
- Restauraci√≥ de focus despr√©s d'animacions
- Persist√®ncia d'estat entre reconstruccions amb mapa est√†tic

Context del Domini
Sabina demostra una arquitectura Flutter avan√ßada amb:
- Gesti√≥ d'estat reactiva sense dependencies
- Sistema de traduccions i internacionalitzaci√≥ complet
- Pattern MVC adaptat per Flutter
- Componentitzaci√≥ amb separation of concerns
- Optimitzaci√≥ de rendiment a nivell de widget

Regles d'Or del Projecte ‚≠êÔ∏è
1. Qualsevol LdLabel que mostri dades que canvien SEMPRE necessita un function observer dedicat.
2. Per dades que canvien freq√ºentment (>1 vegada/s) utilitzar `setTranslationArgsIsolated` per evitar reconstruccions innecess√†ries.
3. NO invocar mai `WidgetsBinding.instance.addPostFrameCallback` dins de m√®todes `build()`.
4. NO connectar mai directament un LdLabel com a observador d'un model; sempre utilitzar un function observer dedicat.
5. SEMPRE gestionar valors nuls adequadament, especialment en LdTextField i models similars.
6. El sistema de traduccions ha de poder traduir m√∫ltiples claus dins d'un mateix text, no nom√©s la primera.
7. En components amb animaci√≥ (com LdFoldableContainer) SEMPRE preservar el mateix widget fill tant en estat visible com ocult.
8. MAI utilitzar 'null' com a valor d'al√ßada en AnimatedContainer, sempre utilitzar un valor finit.
9. Per a components expandibles amb contingut gran, afegir sempre un SingleChildScrollView al contingut.
10. SEMPRE implementar mecanismes de recuperaci√≥ robustos per a models perduts o estats inconsistents.
11. Persistir l'estat entre reconstruccions utilitzant un mapa est√†tic i actualitzar-lo abans de canvis d'idioma o tema.
12. MAI accedir directament a propietats d'un widget just despr√©s de crear-lo; utilitzar callbacks per gestionar canvis d'estat.